/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("self.addEventListener('message', OutlineGeometry);\r\n\r\nfunction OutlineGeometry (mesh, thresholdAngle) {\r\n\r\n    if (mesh instanceof THREE.Mesh){\r\n        self.postMessage({ err : new Error('The given mesh is not a ' + typeof(mesh))})\r\n    } else {\r\n        let geometry = mesh.geometry;\r\n        let outline = THREE.BufferGeometry();\r\n        self.postMessage({log: \"new Node send\"});\r\n        var thresholdDot = Math.cos( Math.PI / 180 * thresholdAngle );\r\n\r\n        var edge = [ 0, 0 ], hash = {}, i, j, l, face, key;\r\n\r\n        function sortFunction( a, b ) {\r\n\r\n            return a - b;\r\n\r\n        }\r\n\r\n        var keys = [ 'a', 'b', 'c' ];\r\n\r\n        var geometry2;\r\n\r\n        if ( geometry.isBufferGeometry ) {\r\n\r\n            geometry2 = new THREE.Geometry();\r\n            geometry2.fromBufferGeometry( geometry );\r\n\r\n        } else {\r\n\r\n            geometry2 = geometry.clone();\r\n\r\n        }\r\n\r\n        geometry2.mergeVertices();\r\n        geometry2.computeFaceNormals();\r\n\r\n        var vertices = geometry2.vertices;\r\n        var faces = geometry2.faces;\r\n\r\n        for ( i = 0; i < faces.length; i ++ ) {\r\n\r\n            face = faces[ i ];\r\n\r\n            for ( j = 0; j < 3; j ++ ) {\r\n\r\n                edge[ 0 ] = face[ keys[ j ] ];\r\n                edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\r\n                var line = new THREE.Line3(vertices[edge[ 0 ]], vertices[edge[ 1 ]]);\r\n\r\n                // for each vertex checks if it lies in the edge\r\n                for ( var e = vertices.length - 1; e >= 0; e -- ) {\r\n                    if (e === edge[ 0 ] || e === edge[ 1 ]) continue;\r\n                    var v = vertices[e];\r\n                    var closestPoint = line.closestPointToPoint(v, true);\r\n                    if ((new THREE.Line3(closestPoint, v)).distance() < 1e-5) { //1e-5\r\n                        // mark the current face as splitted so that his cords won't be considered\r\n                        face.splitted = true;\r\n                        // Add two new faces, created splitting the face in two\r\n                        faces.push(new THREE.Face3(\r\n                            e, face[ keys[ ( j + 2 ) % 3 ] ], face[ keys[ ( j ) % 3 ] ],\r\n                            face.normal, face.color, face.materialIndex\r\n                        ));\r\n                        faces.push(new THREE.Face3(\r\n                            e, face[ keys[ ( j + 2 ) % 3 ] ], face[ keys[ ( j + 1 ) % 3 ] ],\r\n                            face.normal, face.color, face.materialIndex\r\n                        ));\r\n                        break;\r\n                    }\r\n                }\r\n                if (face.splitted) break;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        for ( i = faces.length - 1;  i >= 0; i -- ) {\r\n\r\n            face = faces[ i ];\r\n\r\n            if (face.splitted) continue;\r\n\r\n            for ( j = 0; j < 3; j ++ ) {\r\n\r\n                edge[ 0 ] = face[ keys[ j ] ];\r\n                edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n                edge.sort( sortFunction );\r\n\r\n                key = edge.toString();\r\n\r\n                if ( hash[ key ] === undefined ) {\r\n\r\n                    hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\r\n                } else {\r\n\r\n                    hash[ key ].face2 = i;\r\n\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        var coords = [];\r\n\r\n        for ( key in hash ) {\r\n\r\n            var h = hash[ key ];\r\n\r\n            // An edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\r\n            if ( h.face2 !== undefined && faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\r\n                var vertex = vertices[ h.vert1 ];\r\n                coords.push( vertex.x );\r\n                coords.push( vertex.y );\r\n                coords.push( vertex.z );\r\n\r\n                vertex = vertices[ h.vert2 ];\r\n                coords.push( vertex.x );\r\n                coords.push( vertex.y );\r\n                coords.push( vertex.z );\r\n\r\n            }\r\n\r\n        }\r\n\r\n        outline.addAttribute( 'position', new THREE.Float32BufferAttribute( coords, 3 ) );\r\n        self.postMessage({res: outline})\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3ZXIvc3JjL3RocmVlLmpzIC0gdmlld2VyL3dvcmtlci9PdXRsaW5lR2VvbWV0cnkud29ya2VyLmpzP2QxMTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsNERBQTREO0FBQ3RGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQzs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjs7QUFFdEM7O0FBRUEsd0JBQXdCLE9BQU87O0FBRS9CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxTQUFTOztBQUU1Qzs7QUFFQTs7QUFFQSx3QkFBd0IsT0FBTzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQzs7QUFFbkMsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsic2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgT3V0bGluZUdlb21ldHJ5KTtcclxuXHJcbmZ1bmN0aW9uIE91dGxpbmVHZW9tZXRyeSAobWVzaCwgdGhyZXNob2xkQW5nbGUpIHtcclxuXHJcbiAgICBpZiAobWVzaCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpe1xyXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBlcnIgOiBuZXcgRXJyb3IoJ1RoZSBnaXZlbiBtZXNoIGlzIG5vdCBhICcgKyB0eXBlb2YobWVzaCkpfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcclxuICAgICAgICBsZXQgb3V0bGluZSA9IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7bG9nOiBcIm5ldyBOb2RlIHNlbmRcIn0pO1xyXG4gICAgICAgIHZhciB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggTWF0aC5QSSAvIDE4MCAqIHRocmVzaG9sZEFuZ2xlICk7XHJcblxyXG4gICAgICAgIHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fSwgaSwgaiwgbCwgZmFjZSwga2V5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcclxuXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5MjtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkyID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeTIgPSBnZW9tZXRyeS5jbG9uZSgpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdlb21ldHJ5Mi5tZXJnZVZlcnRpY2VzKCk7XHJcbiAgICAgICAgZ2VvbWV0cnkyLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XHJcbiAgICAgICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkyLmZhY2VzO1xyXG5cclxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcbiAgICAgICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG4gICAgICAgICAgICAgICAgZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBuZXcgVEhSRUUuTGluZTModmVydGljZXNbZWRnZVsgMCBdXSwgdmVydGljZXNbZWRnZVsgMSBdXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggdmVydGV4IGNoZWNrcyBpZiBpdCBsaWVzIGluIHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICBmb3IgKCB2YXIgZSA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7IGUgPj0gMDsgZSAtLSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSA9PT0gZWRnZVsgMCBdIHx8IGUgPT09IGVkZ2VbIDEgXSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0aWNlc1tlXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VzdFBvaW50ID0gbGluZS5jbG9zZXN0UG9pbnRUb1BvaW50KHYsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobmV3IFRIUkVFLkxpbmUzKGNsb3Nlc3RQb2ludCwgdikpLmRpc3RhbmNlKCkgPCAxZS01KSB7IC8vMWUtNVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIHRoZSBjdXJyZW50IGZhY2UgYXMgc3BsaXR0ZWQgc28gdGhhdCBoaXMgY29yZHMgd29uJ3QgYmUgY29uc2lkZXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnNwbGl0dGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHR3byBuZXcgZmFjZXMsIGNyZWF0ZWQgc3BsaXR0aW5nIHRoZSBmYWNlIGluIHR3b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUsIGZhY2VbIGtleXNbICggaiArIDIgKSAlIDMgXSBdLCBmYWNlWyBrZXlzWyAoIGogKSAlIDMgXSBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZS5ub3JtYWwsIGZhY2UuY29sb3IsIGZhY2UubWF0ZXJpYWxJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLCBmYWNlWyBrZXlzWyAoIGogKyAyICkgJSAzIF0gXSwgZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLm5vcm1hbCwgZmFjZS5jb2xvciwgZmFjZS5tYXRlcmlhbEluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZmFjZS5zcGxpdHRlZCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggaSA9IGZhY2VzLmxlbmd0aCAtIDE7ICBpID49IDA7IGkgLS0gKSB7XHJcblxyXG4gICAgICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmYWNlLnNwbGl0dGVkKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcclxuICAgICAgICAgICAgICAgIGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xyXG4gICAgICAgICAgICAgICAgZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBoYXNoWyBrZXkgXSA9IHsgdmVydDE6IGVkZ2VbIDAgXSwgdmVydDI6IGVkZ2VbIDEgXSwgZmFjZTE6IGksIGZhY2UyOiB1bmRlZmluZWQgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBoYXNoWyBrZXkgXS5mYWNlMiA9IGk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb29yZHMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICgga2V5IGluIGhhc2ggKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaCA9IGhhc2hbIGtleSBdO1xyXG5cclxuICAgICAgICAgICAgLy8gQW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSAoaW4gZGVncmVlcykgYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIHRoZSBhZGpvaW5pbmcgZmFjZXMgZXhjZWVkcyB0aGlzIHZhbHVlLiBkZWZhdWx0ID0gMSBkZWdyZWUuXHJcbiAgICAgICAgICAgIGlmICggaC5mYWNlMiAhPT0gdW5kZWZpbmVkICYmIGZhY2VzWyBoLmZhY2UxIF0ubm9ybWFsLmRvdCggZmFjZXNbIGguZmFjZTIgXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XHJcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnggKTtcclxuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xyXG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC56ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDIgXTtcclxuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueCApO1xyXG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goIHZlcnRleC55ICk7XHJcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaCggdmVydGV4LnogKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdXRsaW5lLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XHJcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7cmVzOiBvdXRsaW5lfSlcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3ZpZXdlci9zcmMvdGhyZWUuanMgLSB2aWV3ZXIvd29ya2VyL091dGxpbmVHZW9tZXRyeS53b3JrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ })
/******/ ]);